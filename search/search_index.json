{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Initially this course has been conceived as a short course on IoT with the main purpose to give a first understanding of the main issues in developing IoT solutions. We do believe the most efficient way to learn this subject is experimenting, this is way the course encourage attendants to hands-on.</p> <p>No specific background is needed, even if a basic knowledge of electronics and computer science might help. </p> <p>Over the years the course evolved and it is now not so short, however, the idea is to guide the attendants step by step, incrementally.  So it is up to you how far to go. </p>"},{"location":"#tools-and-materials","title":"Tools and Materials","text":"<p>The reference hardware is the ESP32 and we now mostly use PlatformIO. vscode is a nice companion together with  the Platformio extension.</p> <p>Initially we focused on The Espressif software development environment (esp-idf) and FREERTOS. </p> <p>While this is probably the way to go for doing serious stuff, we found the Arduino framework to better suits the goal of providing a step-by-step introduction. Furthermore, Arduino on the ESP32 relies \"secretely\"  on FreeRTOS, even if to take full advantage of it, esp-idf is a must. </p> <p>The list of material for each group: 1 ESP32-DevKit, a breadboard, some wires and resistors, one led, one button, one potentiometer and one 3 Axis Accelerometer Gyroscope</p> <ul> <li> <p>ESP32-DevKit e.g. Available on Amazon</p> </li> <li> <p>A breadboard e.g. Available on Amazon</p> </li> <li> <p>Wires e.g. Available on Amazon</p> </li> <li> <p>Resistors e.g. Available on Amazon</p> </li> <li> <p>Minimal actuator, namely a led and resistors - resistor 330 Ohm e.g. Available on Amazon</p> </li> <li> <p>Minimal analog sensor, namely a potentiometer 10 KOhm e.g. Available on Amazon</p> </li> <li> <p>Minimal digital sensor, namely a button - resistor 1 KOhm e.g. Available on Amazon</p> </li> <li> <p>A more interesting digital vibration sensor SW-420 e.g. Available on Amazon</p> </li> <li> <p>3 Axis Accelerometer Gyroscope Sensor Module GY-521 MPU6050 Modulee.g. Available on Amazon</p> </li> </ul>"},{"location":"#useful-links","title":"Useful links","text":"<ul> <li>The Espressif software development environment</li> <li>Arduino Ide</li> <li>PlatformIO</li> <li>Wokwi</li> <li>FREERTOS</li> <li>IoT-LAB </li> <li>Thingsboard</li> <li>Adafruit Io</li> <li>A short paper on this course</li> <li>Lastminuteengineers</li> <li>Random Nerd Tutorial</li> <li>Arduino Learn</li> <li>Andreas Spiess Youtube channel</li> </ul>"},{"location":"#editions","title":"Editions","text":"<p>Some material of this course is used in the Sapienza University of Rome course on Internet of Thing Algorithms and Services </p> <p>First edition of the course 19th (Session 1 and 2) and 21st (Session 3 and 4) of July 2023 in the University of Stellenbosch (South Africa) during an Erasmus+ staff mobility for teaching visit. About 40 participants selected among more the 100 candidates. </p> <p></p> <p>Second edition of the course 25th, 29th and 31st Of October and 4th of November 2024 in the Business and Technology University (Tbilisi, Georgia) during an Erasmus+ staff mobility for teaching visit. Two groups of 10 students each. </p> <p> </p>"},{"location":"crowdsourcing/","title":"Interact with a Mobile Phone via BLE","text":"<p>Nowadays, mobile devices, such as our smart phone or watch are plenty of sensors. There are many examples to collect data from such sensors by mobile apps. </p> <p>Warning</p> <p>In this course we are NOT interested in mobile applications using ONLY the sensors available in you mobile phone. </p> <p>Instead, we aim at developing solution where a node, in our case an ESP32, collects some sensor data and interact with the mobile phone (e.g. via BLE) to possibly enrich the observed data by the phone sensors and to deliver them to the backend.  </p> <p>Warning</p> <p>Remember, this is a course on IoT, we are not interested in fancy mobile app, and as much work is done by the node (i.e. the ESP32), as better it is. There are plenty of useful resources on developing fancy mobile apps and backends, but we are mostly interested in the node  </p> <p>For this reason, we will use fast prototyping mobile app tools. </p>"},{"location":"crowdsourcing/#remotexy","title":"Remotexy","text":"<p>Remotexy it's probably the easiest way </p>"},{"location":"crowdsourcing/#thunkable","title":"Thunkable","text":"<p>Thunkable is more powerful, but slightly more complex</p> <p></p> <p>The arduino code, adapted from https://www.instructables.com/ESP32-BLE-Android-App-Arduino-IDE-AWESOME/ is the following</p> <pre><code>/*\n    Video: https://www.youtube.com/watch?v=oCMOYS71NIU\n    Based on Neil Kolban example for IDF: https://github.com/nkolban/esp32-snippets/blob/master/cpp_utils/tests/BLE%20Tests/SampleNotify.cpp\n    Ported to Arduino ESP32 by Evandro Copercini\n\n   Create a BLE server that, once we receive a connection, will send periodic notifications.\n   The service advertises itself as: 6E400001-B5A3-F393-E0A9-E50E24DCCA9E\n   Has a characteristic of: 6E400002-B5A3-F393-E0A9-E50E24DCCA9E - used for receiving data with \"WRITE\" \n   Has a characteristic of: 6E400003-B5A3-F393-E0A9-E50E24DCCA9E - used to send data with  \"NOTIFY\"\n\n   The design of creating the BLE server is:\n   1. Create a BLE Server\n   2. Create a BLE Service\n   3. Create a BLE Characteristic on the Service\n   4. Create a BLE Descriptor on the characteristic\n   5. Start the service.\n   6. Start advertising.\n\n   In this example rxValue is the data received (only accessible inside that function).\n   And txValue is the data to be sent, in this example just a byte incremented every second. \n*/\n#include &lt;BLEDevice.h&gt;\n#include &lt;BLEServer.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLE2902.h&gt;\n\n// 78:21:84:9f:24:de\n\nBLECharacteristic *pCharacteristic;\nbool deviceConnected = false;\nfloat txValue = 0;\nconst int readPin = 32; // Use GPIO number. See ESP32 board pinouts\n//const int LED = 9; // Could be different depending on the dev board. I used the DOIT ESP32 dev board.\n\n//std::string rxValue; // Could also make this a global var to access it in loop()\n\n// See the following for generating UUIDs:\n// https://www.uuidgenerator.net/\n\n#define SERVICE_UUID           \"6E400001-B5A3-F393-E0A9-E50E24DCCA9E\" // UART service UUID\n#define CHARACTERISTIC_UUID_RX \"6E400002-B5A3-F393-E0A9-E50E24DCCA9E\" // Qui ricevi da EPS32\n#define CHARACTERISTIC_UUID_TX \"6E400003-B5A3-F393-E0A9-E50E24DCCA9E\" // Qui invii\n\nclass MyServerCallbacks: public BLEServerCallbacks {\n    void onConnect(BLEServer* pServer) {\n      deviceConnected = true;\n    };\n\n    void onDisconnect(BLEServer* pServer) {\n      deviceConnected = false;\n    }\n};\n\n\n\nclass MyCallbacks: public BLECharacteristicCallbacks {\n    void onWrite(BLECharacteristic *pCharacteristic) {\n      std::string rxValue = pCharacteristic-&gt;getValue();\n\n      char letto[] = \"          \";\n\n      if (rxValue.length() &gt; 0) {\n        Serial.println(\"*********\");\n        Serial.print(\"Received Value: \");\n\n        for (int i = 0; i &lt; rxValue.length(); i++) {\n          Serial.print(rxValue[i]);\n          letto[i]=rxValue[i];\n        }\n\n        Serial.println();\n\n        String a = String(letto);\n\n        Serial.print(a.toFloat());\n\n        // Do stuff based on the command received from the app\n        if (rxValue.find(\"A\") != -1) { \n          Serial.print(\"Turning ON!\");\n          digitalWrite(LED, HIGH);\n        }\n        else if (rxValue.find(\"B\") != -1) {\n          Serial.print(\"Turning OFF!\");\n          digitalWrite(LED, LOW);\n        }\n\n        Serial.println();\n        Serial.println(\"*********\");\n      }\n    }\n};\n\nvoid setup() {\n  Serial.begin(115200);\n\n  pinMode(LED, OUTPUT);\n\n  // Create the BLE Device\n  BLEDevice::init(\"ESP32 UART Test\"); // Give it a name\n\n  Serial.print(\"local BLE Address is: \");\n  Serial.println(BLEDevice::getAddress().toString().c_str());\n\n  // Create the BLE Server\n  BLEServer *pServer = BLEDevice::createServer();\n  pServer-&gt;setCallbacks(new MyServerCallbacks());\n\n  // Create the BLE Service\n  BLEService *pService = pServer-&gt;createService(SERVICE_UUID);\n\n\n  // BleCharacteristic deviceHealthCharacteristic(\"deviceHealth\", BleCharacteristicProperty::READ, deviceHealthUuid, serviceUuid);\n  // see https://community.thunkable.com/t/ble-hrm-reading-bpm/2441754/6\n\n\n  // Create a BLE Characteristic\n  pCharacteristic = pService-&gt;createCharacteristic(\n                      CHARACTERISTIC_UUID_TX,\n                      //BLECharacteristic::PROPERTY_NOTIFY\n                      BLECharacteristic::PROPERTY_READ\n                    );\n\n  pCharacteristic-&gt;addDescriptor(new BLE2902());\n\n  BLECharacteristic *pCharacteristic = pService-&gt;createCharacteristic(\n                                         CHARACTERISTIC_UUID_RX,\n                                         BLECharacteristic::PROPERTY_WRITE\n                                       );\n\n  pCharacteristic-&gt;setCallbacks(new MyCallbacks());\n\n  // Start the service\n  pService-&gt;start();\n\n  // Start advertising\n  pServer-&gt;getAdvertising()-&gt;start();\n  Serial.println(\"Waiting a client connection to notify...\");\n}\n\nvoid loop() {\n\n  if (deviceConnected) {\n    // Fabricate some arbitrary junk for now...\n    txValue = analogRead(readPin) / 3.456; // This could be an actual sensor reading!\n\n    // Let's convert the value to a char array:\n    char txString[8]; // make sure this is big enuffz\n    dtostrf(txValue, 1, 2, txString); // float_val, min_width, digits_after_decimal, char_buffer\n\n//    pCharacteristic-&gt;setValue(&amp;txValue, 1); // To send the integer value\n    pCharacteristic-&gt;setValue(\"Hello!\"); // Sending a test message\n    //pCharacteristic-&gt;setValue(txString);\n\n    pCharacteristic-&gt;notify(); // Send the value to the app!\n    Serial.print(\"*** Sent Value: \");\n    Serial.print(txString);\n    Serial.println(\" ***\");\n\n    // You can add the rxValue checks down here instead\n    // if you set \"rxValue\" as a global var at the top!\n    // Note you will have to delete \"std::string\" declaration\n    // of \"rxValue\" in the callback function.\n//    if (rxValue.find(\"A\") != -1) { \n//      Serial.println(\"Turning ON!\");\n//      digitalWrite(LED, HIGH);\n//    }\n//    else if (rxValue.find(\"B\") != -1) {\n//      Serial.println(\"Turning OFF!\");\n//      digitalWrite(LED, LOW);\n//    }\n  }\n\n  delay(1000);\n}\n</code></pre> <pre><code>// Adapted from https://github.com/SIMS-IOT-Devices/FreeRTOS-ESP-IDF-BLE-Server\n\n#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/event_groups.h\"\n#include \"esp_event.h\"\n#include \"nvs_flash.h\"\n#include \"esp_log.h\"\n#include \"esp_nimble_hci.h\"\n#include \"nimble/nimble_port.h\"\n#include \"nimble/nimble_port_freertos.h\"\n#include \"host/ble_hs.h\"\n#include \"services/gap/ble_svc_gap.h\"\n#include \"services/gatt/ble_svc_gatt.h\"\n#include \"sdkconfig.h\"\n\nchar *TAG = \"BLE-Server\";\nuint8_t ble_addr_type;\nvoid ble_app_advertise(void);\n\n//@_____________________Define UUIDs______________________________________\n//!! b2bbc642-46da-11ed-b878-0242ac120002\n//static const ble_uuid128_t gatt_svr_svc_uuid =\n//    BLE_UUID128_INIT(0x02, 0x00, 0x12, 0xac, 0x42, 0x02, 0x78, 0xb8, 0xed, 0x11, 0xda, 0x46, 0x42, 0xc6, 0xbb, 0xb2);\n\nstatic const ble_uuid128_t gatt_svr_svc_uuid =\n    BLE_UUID128_INIT(0x9e, 0xca, 0xdc, 0x24, 0x0e, 0xe5, 0xa9, 0xe0, 0x93, 0xf3, 0xa3, 0xb5, 0x01, 0x00, 0x40, 0x6e);\n\n\n//!! c9af9c76-46de-11ed-b878-0242ac120002\n//static const ble_uuid128_t gatt_svr_chr_uuid =\n//    BLE_UUID128_INIT(0x02, 0x00, 0x12, 0xac, 0x42, 0x02, 0x78, 0xb8, 0xed, 0x11, 0xde, 0x46, 0x76, 0x9c, 0xaf, 0xc9);\n\n// 6E400002-B5A3-F393-E0A9-E50E24DCCA9E    \n\nstatic const ble_uuid128_t gatt_svr_chr_read_uuid =\n    BLE_UUID128_INIT(0x9e, 0xca, 0xdc, 0x24, 0x0e, 0xe5, 0xa9, 0xe0, 0x93, 0xf3, 0xa3, 0xb5, 0x02, 0x00, 0x40, 0x6e);\nstatic const ble_uuid128_t gatt_svr_chr_write_uuid =\n    BLE_UUID128_INIT(0x9e, 0xca, 0xdc, 0x24, 0x0e, 0xe5, 0xa9, 0xe0, 0x93, 0xf3, 0xa3, 0xb5, 0x03, 0x00, 0x40, 0x6e);\n\n\n// Write data to ESP32 defined as server\nstatic int device_write(uint16_t conn_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)\n{\n    printf(\"Data from the client: %.*s\\n\", ctxt-&gt;om-&gt;om_len, ctxt-&gt;om-&gt;om_data);\n    return 0;\n}\n\n// Read data from ESP32 defined as server\nstatic int device_read(uint16_t con_handle, uint16_t attr_handle, struct ble_gatt_access_ctxt *ctxt, void *arg)\n{\n    os_mbuf_append(ctxt-&gt;om, \"Data from the server\", strlen(\"Data from the server\"));\n    return 0;\n}\n\nstatic const struct ble_gatt_svc_def gatt_svcs[] = {\n    {.type = BLE_GATT_SVC_TYPE_PRIMARY,\n     .uuid = &amp;gatt_svr_svc_uuid.u,                      // Define UUID for device type\n     .characteristics = (struct ble_gatt_chr_def[]){\n         {.uuid = &amp;gatt_svr_chr_write_uuid.u,           // Define UUID for reading\n          .flags = BLE_GATT_CHR_F_READ,\n          .access_cb = device_read},\n         {.uuid = &amp;gatt_svr_chr_read_uuid.u,           // Define UUID for writing\n          .flags = BLE_GATT_CHR_F_WRITE,\n          .access_cb = device_write},\n         {0}}},\n    {0}};\n\n\n\n// BLE event handling\nstatic int ble_gap_event(struct ble_gap_event *event, void *arg)\n{\n    switch (event-&gt;type)\n    {\n    // Advertise if connected\n    case BLE_GAP_EVENT_CONNECT:\n        ESP_LOGI(\"GAP\", \"BLE GAP EVENT CONNECT %s\", event-&gt;connect.status == 0 ? \"OK!\" : \"FAILED!\");\n        if (event-&gt;connect.status != 0)\n        {\n            ble_app_advertise();\n        }\n        break;\n    // Advertise again after completion of the event\n    case BLE_GAP_EVENT_ADV_COMPLETE:\n        ESP_LOGI(\"GAP\", \"BLE GAP EVENT\");\n        ble_app_advertise();\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\n// Define the BLE connection\nvoid ble_app_advertise(void)\n{\n    // GAP - device name definition\n    struct ble_hs_adv_fields fields;\n    const char *device_name;\n    memset(&amp;fields, 0, sizeof(fields));\n    device_name = ble_svc_gap_device_name(); // Read the BLE device name\n    fields.name = (uint8_t *)device_name;\n    fields.name_len = strlen(device_name);\n    fields.name_is_complete = 1;\n    ble_gap_adv_set_fields(&amp;fields);\n\n    // GAP - device connectivity definition\n    struct ble_gap_adv_params adv_params;\n    memset(&amp;adv_params, 0, sizeof(adv_params));\n    adv_params.conn_mode = BLE_GAP_CONN_MODE_UND; // connectable or non-connectable\n    adv_params.disc_mode = BLE_GAP_DISC_MODE_GEN; // discoverable or non-discoverable\n    ble_gap_adv_start(ble_addr_type, NULL, BLE_HS_FOREVER, &amp;adv_params, ble_gap_event, NULL);\n}\n\n// The application\nvoid ble_app_on_sync(void)\n{\n    ble_hs_id_infer_auto(0, &amp;ble_addr_type); // Determines the best address type automatically\n    ble_app_advertise();                     // Define the BLE connection\n}\n\n// The infinite task\nvoid host_task(void *param)\n{\n    nimble_port_run(); // This function will return only when nimble_port_stop() is executed\n}\n\nvoid app_main()\n{\n    nvs_flash_init();                          // 1 - Initialize NVS flash using\n    //esp_nimble_hci_and_controller_init();      // 2 - Initialize ESP controller\n    nimble_port_init();                        // 3 - Initialize the host stack\n    ble_svc_gap_device_name_set(\"BLE-Server\"); // 4 - Initialize NimBLE configuration - server name\n    ble_svc_gap_init();                        // 4 - Initialize NimBLE configuration - gap service\n    ble_svc_gatt_init();                       // 4 - Initialize NimBLE configuration - gatt service\n    ble_gatts_count_cfg(gatt_svcs);            // 4 - Initialize NimBLE configuration - config gatt services\n    ble_gatts_add_svcs(gatt_svcs);             // 4 - Initialize NimBLE configuration - queues gatt services.\n    ble_hs_cfg.sync_cb = ble_app_on_sync;      // 5 - Initialize application\n    nimble_port_freertos_init(host_task);      // 6 - Run the thread\n}\n</code></pre>"},{"location":"crowdsourcing/#monitoring-coronavirus","title":"Monitoring Coronavirus","text":"<p>A remarkable use of crowdsensing has been the use of mobile phones for contact tracing, during the COVID-19. Indeed smartphone apps, given accessibility in the time of physical distancing, were widely used for tracking, tracing and educating the public about COVID-19 as reported in Smartphone apps in the COVID-19 pandemic. </p> <p>Note</p> <p>Despite this use case is not consistent with the requirement of integrating external sensors with the mobile phone, we will consider it for its obvious relevance. </p> <p>Many efforts have been put in place to preserve tha anonymity in tracing, however the research community raised a number of issues, as discussed in Anonymous tracing, a dangerous oxymoron </p>"},{"location":"edge/","title":"Edge Computing","text":""},{"location":"energy/","title":"Energy","text":""},{"location":"energy/#how-to-measure-energy-consumption","title":"How to measure energy consumption","text":"<p>https://www.electronicwings.com/esp32/esp32-deep-sleep-mode</p> <ul> <li>Connect board VIN (red wire) to Arduino 5V if you are running a 5V board Arduino (Mega, etc.). If your board is 3V, connect to that instead.</li> <li>Connect board GND (black wire) to Arduino GND</li> <li>Connect board SCL (white wire) to Arduino SCL</li> <li>Connect board SDA (blue wire) to Arduino SDA</li> <li>Connect Vin+ to the positive terminal of the power supply for the circuit under test</li> <li>Connect Vin- to the positive terminal or lead of the load</li> </ul> <p></p> <p>source</p> <pre><code>#include &lt;Wire.h&gt;\n#include &lt;Adafruit_INA219.h&gt;\n\nAdafruit_INA219 ina219;\n\nvoid setup(void) \n{\n  Serial.begin(115200);\n  while (!Serial) {\n      // will pause Zero, Leonardo, etc until serial console opens\n      delay(1);\n  }\n\n  uint32_t currentFrequency;\n  Serial.println(\"Hello!\");\n\n  // Initialize the INA219.\n  // By default the initialization will use the largest range (32V, 2A).  However\n  // you can call a setCalibration function to change this range (see comments).\n  if (! ina219.begin()) {\n    Serial.println(\"Failed to find INA219 chip\");\n    while (1) { delay(10); }\n  }\n  // To use a slightly lower 32V, 1A range (higher precision on amps):\n  //ina219.setCalibration_32V_1A();\n  // Or to use a lower 16V, 400mA range (higher precision on volts and amps):\n  //ina219.setCalibration_16V_400mA();\n  Serial.println(\"Measuring voltage and current with INA219 ...\");\n}\n\nvoid loop(void) \n{\n  float shuntvoltage = 0;\n  float busvoltage = 0;\n  float current_mA = 0;\n  float loadvoltage = 0;\n  float power_mW = 0;\n\n  shuntvoltage = ina219.getShuntVoltage_mV();\n  busvoltage = ina219.getBusVoltage_V();\n  current_mA = ina219.getCurrent_mA();\n  power_mW = ina219.getPower_mW();\n  loadvoltage = busvoltage + (shuntvoltage / 1000);\n\n  Serial.print(busvoltage);\n  Serial.print(\",\");\n  Serial.print(shuntvoltage);\n  Serial.print(\",\");\n  Serial.print(loadvoltage);\n  Serial.print(\",\");\n  Serial.print(current_mA);\n  Serial.print(\",\");\n  Serial.print(power_mW);\n  Serial.println(\"\");\n\n  delay(50);\n}\n</code></pre> <p> </p> <p>source code</p>"},{"location":"energy/#energy-harvesting","title":"Energy Harvesting","text":"<p>https://randomnerdtutorials.com/power-esp32-esp8266-solar-panels-battery-level-monitoring/</p>"},{"location":"filters/","title":"Filters","text":""},{"location":"filters/#hampel-filters","title":"Hampel Filters","text":""},{"location":"filters/#moving-average","title":"Moving Average","text":""},{"location":"filters/#kalman-filters","title":"Kalman Filters","text":"<p>A very nice, rich an exhaustive source of documentation for Kalman filters is available here</p> <p>The main idea is that both our prior knowledge and the measurements of our sensors are to some extent inaccurate. To model such inaccuracy we use a Gaussian with mean \\(\\mu\\) and variance \\(\\rho\\)</p> <p></p> <p>At each iteration we have our prior knowledge (in blue) and a new measurement (in orange) and we account for both source of information computing an average (in green)</p> <p></p> <p>The final mean gets shifted which is in between the two old means, the mean of the prior, and the mean of the measurement. It\u2019s slightly further on the measurement side because the measurement was more certain as to where the vehicle is than prior. The more certain we are, the more we pull the mean on the direction of the certain answer. source</p> <p>Iteration after iteration the variance decreases (the spread of the blue gaussian), providing a better estimation (in green) despite the noisy measurements (in red) source</p> <p></p> <p>A reference library is available here</p>"},{"location":"intro/","title":"A Reference Architecture","text":""},{"location":"intro/#takeaway-one","title":"Takeaway ONE","text":"<ul> <li>IoT is fuel for Big Data Analytics</li> <li> <p>\"When you can measure ... you know something\". Lord Kelvin docet.</p> </li> <li>IoT provide quantitative evidences on  phenomena that we used to investigate only qualitatively</li> </ul>"},{"location":"intro/#takeaway-two","title":"Takeaway TWO","text":"<ul> <li>IoT is a network of resource constrained devices</li> <li>Constraints require design choices</li> <li>Beyond the maker approach, namely when effectiveness meets efficiency</li> </ul>"},{"location":"ml/","title":"Tensorflow Lite Micro on ESP32","text":"<p>Reference examples are available here. You have to download from github esp-nn and esp32-camera and place them into the relative folders under components.</p> <p>Then go to examples/hello_worlds and as usual idf.py build, idf.py flash and finally idf.py monitor.</p> <p>A nice explanation on how the model is generated can be found on the book TinyML by Pete Warden, Daniel Situnayake. The corresponding jupyter notebook is available here</p> <p>Some other useful resources are listed below:</p> <ul> <li>First steps with ESP32 and TensorFlow Lite for Microcontrollers</li> <li>Get started with microcontrollers</li> </ul>"},{"location":"os/","title":"We need an OS","text":"<p>Giorgio Grisetti's lectures are an excellent resource. </p> <p>GOAL: Small experiment (a single sensor). Focus on efficiency, namely doing the things right, i.e., the Engineers approach. Use metrics to measure to what extent your solution satisfies the user requirements.</p> <p>Well, to develop an IoT application as an engineer, we do need a Real-Time Operating System (RTOS). What is An RTOS?. </p> <p>Embedded systems often have real time requirements. A real time requirements is one that specifies that the embedded system must respond to a certain event within a strictly defined time (the deadline). A guarantee to meet real time requirements can only be made if the behaviour of the operating system's scheduler can be predicted (and is therefore deterministic). FreeRTOS, achieve determinism by allowing the user to assign a priority to each thread of execution. The scheduler then uses the priority to know which thread of execution to run next. In FreeRTOS, a thread of execution is called a task.</p> <p>Here there is a nice explanation of the main features provided by FreeRTOS, namely </p> <ul> <li>Multitasking</li> <li>Scheduling</li> <li>Context Switching</li> <li>Real Time Applications</li> <li>Real Time Scheduling</li> </ul> <p>FreeRTOS FAQ - What is This All About?</p> <p>Finally a nice example of the design of a real-time application </p> <p>A book on FreeRTOS.</p>"},{"location":"os/#development-environment","title":"Development environment","text":"<p>To develop our solution on our ESP32, we need to setup the environment as described here. A very convenient way is to use docker as explained here. </p> <p>To further simplify the development process, a multi-platform Virtualbox image is available here. Next we will focus on this method. Credentials to work with the virtual machine are root/root and devel/devel and we will connect in ssh as explained below. </p> <p>The reference folder for the code and the examples is https://github.com/espressif/esp-idf.git which is already available on the virtual machine on </p> <ol> <li><code>ssh devel@localhost -p 2222</code> ... the password is devel</li> <li><code>get_idf</code> ... we set up the development environment</li> <li><code>cd ~/esp</code></li> <li><code>cp -r ./esp-idf/examples/get-started/hello_world/ ./workshop/</code> ... make a copy of a dir in the example in the workshop dir </li> <li><code>cd ./workshop/hello_world/</code></li> <li><code>idf.py build</code> ... i t takes some time</li> <li><code>idf.py flash</code> ... be sure the ESP32 is connected to \\dev\\ttyUSB0 and check it is visible in the virtual machine</li> <li><code>idf.py monitor</code> ... to exit from the monitor ctrl+T ctrl+X</li> </ol> <p>NOTE in some cases you can configure specific parameters running idf.py menuconfig</p> <p>In the virtual machine you have first to  <code>export LC_ALL=C</code></p>"},{"location":"os/#clone-only-the-relevant-code","title":"Clone only the relevant code","text":"<pre><code># Create a directory, so Git doesn't get messy, and enter it\nmkdir code_from_git &amp;&amp; cd code_from_git\n\n# Start a Git repository\ngit init\n\n# Track repository, do not enter subdirectory\ngit remote add -f origin https://github.com/andreavitaletti/IoT_short_course\n\n# Enable the tree check feature\ngit config core.sparseCheckout true\n\n# Create a file in the path: .git/info/sparse-checkout\n# That is inside the hidden .git directory that was created\n# by running the command: git init\n# And inside it enter the name of the sub directory you only want to clone\necho 'src/freertos' &gt;&gt; .git/info/sparse-checkout\n\n## Download with pull, not clone\ngit pull origin main\n</code></pre>"},{"location":"os/#a-quick-introduction-to-tasks","title":"A quick introduction to tasks","text":"<p>Based on ESP32 ESP-IDF FreeRTOS Tutorial: Learn to Create Tasks. The code is available on our github repo</p>"},{"location":"os/#the-examples-of-session-2-on-freertos","title":"The examples of SESSION 2 on FreeRTOS","text":"<p>In this section we will implement the reference examples developed in day2 into FreeRTOS. The idea is to take inspiration from the examples available at https://github.com/espressif/esp-idf/tree/master/examples and modify them to get the same behavior of the ones developed in DAY2</p> <ul> <li>The simplest actuator, namely a led</li> <li>The Simplest sensor, namely a button</li> <li>A bit more interesting sensor, namely a potentiometer</li> <li>A simple example with SR04 Ultrasonic Sensor</li> <li>It's time to be connected by MQTT</li> <li>About the vibration sensor SW-420 ... have a look here</li> </ul> <p>Nice tutorials on the same topics are also available here</p>"},{"location":"os/#data-streaming-in-industrial-iot","title":"Data Streaming in Industrial IoT","text":"<ul> <li>MQTT</li> <li>OPCUA</li> <li>Apache Kafka</li> </ul>"},{"location":"real/","title":"It is time to Work with a real device","text":"<p>Lastminuteengineers and Random Nerd Tutorial are plenty of excellent examples to integrate a multitude of sensors and actuators, and to interact with a number of protocols.</p> <p>Fact</p> <p>Exactly the same code you wrote in the simulator, works on the real device, but in the real device you can do even more!</p> <ul> <li>You can easily download the code from Wokwi in the form of a zip project file. </li> </ul> <p></p> <ul> <li>One convenient possibility is to use Arduino IDE </li> <li>Since we are using the ESP32, you have to follow these intructions</li> <li>Select the DOIT ESP32 DEVKIT V1 as in the picture below and upload the code</li> </ul> <p></p> <ul> <li>Another option is to use PlatformIO. In particular I like the vscode extension. </li> <li>To work with the ESP32, this is the minimal setup for the platformio.ini file</li> </ul> <pre><code>[env:esp32dev]\nplatform = espressif32\nboard = esp32dev\nframework = arduino\n\n; Custom Serial Monitor port\nmonitor_port = /dev/ttyUSB0\n\n; Custom Serial Monitor speed (baud rate)\nmonitor_speed = 115200\n</code></pre>"},{"location":"real/#from-wokwi-to-a-real-device","title":"From Wokwi to a real device","text":"<ol> <li>Compile the code and on the code editor press F1 to download the firmware. It is a .bin file, let's name it sketch.bin file </li> <li> <p><code>esptool.py --chip esp32 --port \"/dev/ttyUSB0\" --baud 921600  --before default_reset --after hard_reset write_flash  -z --flash_mode keep --flash_freq keep --flash_size keep 0x1000 \"bootloader.bin\" 0x8000 \"partitions.bin\" 0xe000 \"boot_app0.bin\" 0x10000 \"sketch.bin\"</code> Once partitions and bootloader are uploaded, you can simply upload the sketch. To upload for the first time the partitions and the bootloader you can simply used arduino IDE </p> </li> <li> <p><code>esptool.py --chip esp32 --port \"/dev/ttyUSB0\" --baud 921600  --before default_reset --after hard_reset write_flash  -z --flash_mode keep --flash_freq keep --flash_size keep 0x10000 ./sketch.bin</code></p> </li> </ol> <p>In principle you can even use a Web tool</p>"},{"location":"real/#partition-table","title":"Partition Table","text":"# Name Type SubType Offset Size Flags nvs data nvs 0x9000 0x5000 otadata data ota 0xe000 0x2000 app0 app ota_0 0x10000 0x140000 app1 app ota_1 0x150000 0x140000 spiffs data spiffs 0x290000 0x160000 coredump data coredump 0x3F0000 0x10000"},{"location":"sample/","title":"Sample the environment","text":"<p>Usually IoT applications need to observe a physical phenomenon. This is done by sampling.</p>"},{"location":"sample/#fast-fourier-transform-fft","title":"Fast Fourier Transform (FFT)","text":"<p>Colab Notebook on FFT</p> <p>arduinoFFT library</p> <p>In the following example the signal is generated internally by the node.</p> <p>on wokwi</p> <pre><code>include &lt;arduinoFFT.h&gt;\n\n/*\nThese values can be changed in order to evaluate the functions\n*/\nconst uint16_t samples = 64; //This value MUST ALWAYS be a power of 2\nconst double signalFrequency = 500;\nconst double samplingFrequency = 5000;\nconst uint8_t amplitude = 100;\n\n/*\nThese are the input and output vectors\nInput vectors receive computed results from FFT\n*/\ndouble vReal[samples];\ndouble vImag[samples];\n\n/* Create FFT object */\nArduinoFFT&lt;double&gt; FFT = ArduinoFFT&lt;double&gt;(vReal, vImag, samples, samplingFrequency);\n\nvoid setup()\n{\n  Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"Ready\");\n}\n\nvoid loop()\n{\n  /* Build raw data */\n  double ratio = twoPi * signalFrequency / samplingFrequency; // Fraction of a complete cycle stored at each sample (in radians)\n  for (uint16_t i = 0; i &lt; samples; i++)\n  {\n    vReal[i] = int8_t(amplitude * sin(i * ratio) / 2.0);/* Build data with positive and negative values*/\n    vImag[i] = 0.0; //Imaginary part must be zeroed in case of looping to avoid wrong calculations and overflows\n  }\n  // ...\n  double x = FFT.majorPeak();\n  Serial.println(x, 6);\n  while(1); /* Run Once */\n  // delay(2000); /* Repeat after delay */\n}\n</code></pre> <p>More realistically the signal is observed by the ADC, as in the following example</p> <p></p> <p>on wokwi</p> <pre><code>#include \"arduinoFFT.h\"\n\n/*\nThese values can be changed in order to evaluate the functions\n*/\n#define CHANNEL 12\nconst uint16_t samples = 64; //This value MUST ALWAYS be a power of 2\nconst double samplingFrequency = 100; //Hz, must be less than 10000 due to ADC\nunsigned int sampling_period_us;\nunsigned long microseconds;\n\n/*\nThese are the input and output vectors\nInput vectors receive computed results from FFT\n*/\ndouble vReal[samples];\ndouble vImag[samples];\n\n/* Create FFT object */\nArduinoFFT&lt;double&gt; FFT = ArduinoFFT&lt;double&gt;(vReal, vImag, samples, samplingFrequency);\n\nvoid setup()\n{\n  sampling_period_us = round(1000000*(1.0/samplingFrequency));\n  Serial.begin(115200);\n  while(!Serial);\n  Serial.println(\"Ready\");\n}\n\nvoid loop()\n{\n  /*SAMPLING*/\n  microseconds = micros();\n  for(int i=0; i&lt;samples; i++)\n  {\n      vReal[i] = analogRead(CHANNEL);\n      vImag[i] = 0;\n      while(micros() - microseconds &lt; sampling_period_us){\n        //empty loop\n      }\n      microseconds += sampling_period_us;\n  }\n  // ... \n  double x = FFT.majorPeak();\n  Serial.println(x, 6); //Print out what frequency is the most dominant.\n  while(1); /* Run Once */\n  // delay(2000); /* Repeat after delay */\n}\n</code></pre>"},{"location":"sample/#a-virtual-signal","title":"A virtual signal","text":"<p>A virtual signal is a practical approach to generate arbitrary signals using one EPS32 as the signal generator, and the other as the sampler. </p> <p>The two ESP32 are connected as in the following picture</p> <p></p> <p>The node on the left works as a virtual signal, it generates a signal using the DAC on PIN 25.  The node on the right sample the generated signal by the ADC and print the FFT. </p>"},{"location":"sample/#the-signal-generator","title":"The Signal Generator","text":"<pre><code>#include &lt;Arduino.h&gt;\n\n// Define the DAC and ADC pins\nconst int dacPin = 25;   // DAC1 (GPIO 25) for sinusoid output\n\n// Parameters for the sine wave\nconst int amplitude = 100;   // Amplitude of the sine wave (max 255 for 8-bit DAC)\nconst int offset = 128;      // DC offset (middle of the DAC range)\nconst float signalFrequency = 5.0;  // Frequency of the sine wave in Hz\nint samplingFrequencyDAC = 1000; // sampling theorem should be at least 2*frequency\n\nvoid setup() {\n  Serial.begin(115200);\n\n  // Initialize DAC pin (GPIO 25)\n  dacWrite(dacPin, 0);  // Initialize DAC with a low value\n\n}\n\nvoid loop() {\n      for (int i = 0; i &lt; samplingFrequencyDAC; i++) {\n      int sineValue = (int)(amplitude * sin(2.0 * PI * signalFrequency * i / samplingFrequencyDAC) + offset);\n      dacWrite(dacPin, sineValue);  // Write to DAC (8-bit value)\n      Serial.print(\"&gt;\");\n      Serial.print(\"dac:\");    \n      Serial.println(sineValue);\n      delay(round(1.0/samplingFrequencyDAC*1000));\n      } \n\n}\n</code></pre>"},{"location":"sample/#the-sampler","title":"The Sampler","text":"<pre><code>#include &lt;Arduino.h&gt;\n\nconst int adcPin = 34;   // ADC1 (GPIO 34) for reading the sinusoid\nint samplingFrequencyADC = 500; // sampling theorem should be at least 2*frequency\nconst uint16_t samples = 512; \n\nvoid setup() {\n  Serial.begin(115200);\n  analogReadResolution(10); \n  analogSetAttenuation(ADC_11db);  // Set ADC attenuation (default 0dB)\n}\n\nvoid loop() {\n\n  for(int i=0; i&lt;samples; i++)\n   {\n      Serial.print(\"&gt;\");\n      Serial.print(\"adc:\");    \n      Serial.println(analogRead(adcPin)-512);\n      delay(round(1.0/samplingFrequencyADC*1000));\n  }\n}\n</code></pre> <p>source code</p>"},{"location":"sample/#a-possible-alternative-using-the-pc","title":"A possible alternative using the PC","text":"<p>ref</p> <p><code>python3 -m pip install sounddevice</code></p> <pre><code># Use the sounddevice module\n# http://python-sounddevice.readthedocs.io/en/0.3.10/\n\nimport numpy as np\nimport sounddevice as sd\nimport time\n\n# Samples per second\nsps = 44100\n\n# Frequency / pitch\nfreq_hz = 2\n\n# Duration\nduration_s = 5.0\n\n# Attenuation so the sound is reasonable\natten = 1.0 # 0.3\n\n# NumpPy magic to calculate the waveform\neach_sample_number = np.arange(duration_s * sps)\nwaveform = np.sin(2 * np.pi * each_sample_number * freq_hz / sps)\nwaveform_quiet = waveform * atten\n\n# Play the waveform out the speakers\nsd.play(waveform_quiet, sps)\ntime.sleep(duration_s)\nsd.stop()\n</code></pre> <p>Online Tone Generator</p>"},{"location":"scale/","title":"Scale-up","text":"<p>GOAL: Scale-up in a realistic environment.</p> <p>IoT-LAB provides a very large scale infrastructure suitable for testing small wireless sensor devices and heterogeneous communicating objects.</p> <p>Even if the ESP32 is not currently among the supported hardware, IoT-LAB supports FreeRTOS.</p> <ul> <li>Once you have setup a user connect to a lab by ssh, as an example</li> </ul> <pre><code>ssh vitalett@grenoble.iot-lab.info\n</code></pre> <ul> <li>Follow the instructions here to run FreeRTOS on IoT-LAB</li> <li>The reference code is available on https://github.com/iot-lab/openlab and in particular we are inetrested in the tutorial</li> <li>Once the code has been compiled, it can run into an experiment as explained here</li> <li>A quite unique feature, is the ability to perform consuption monitoring as explained here. To plot the graphs, download the oml files and use the following tools</li> </ul>"},{"location":"scale/#iot-lab","title":"IOT-LAB","text":""},{"location":"scale/#run-a-lorawan-experiment","title":"Run a Lorawan experiment","text":"<pre><code>ssh vitalett@saclay.iot-lab.info \n</code></pre> <pre><code>git clone https://github.com/FreeRTOS/FreeRTOS-LTS.git\ncd FreeRTOS-LTS/FreeRTOS\ngit clone https://github.com/Lora-net/LoRaMac-node.git\ncd cd LoRaMac-node/\n</code></pre> <pre><code>nano  src/boards/B-L072Z-LRWAN1/board.c\n\n// change the baudrate to 115200 to be compatible with iot-lab serial \n\nUartConfig( &amp;Uart2, RX_TX, 115200, UART_8_BIT, UART_1_STOP_BIT, NO_PARITY, NO_FLOW_CTRL );\n</code></pre> <p><pre><code>nano src/peripherals/soft-se/se-identity.h\n\n// update credentials to connect to TTN\n#define STATIC_DEVICE_EUI       1\n#define LORAWAN_DEVICE_EUI      LORAWAN_DEVICE_EUI_ON_TTN\n#define LORAWAN_JOIN_EUI        LORAWAN_APP_EUI_ON_TTN\n#define STATIC_DEVICE_ADDRESS   1\n#define LORAWAN_DEVICE_ADDRESS  DEVICE_ADDRESS_TTN\n\n.KeyID = NWK_KEY,           \n.KeyValue = LORAWAN_APP_KEY_ON_TTN\n</code></pre> </p> <pre><code>mkdir build\ncd build\n\ncmake -DCMAKE_BUILD_TYPE=Release         -DTOOLCHAIN_PREFIX=\"/opt/gcc-arm-none-eabi-4_9-2015q1/\"      -DCMAKE_TOOLCHAIN_FILE=\"../cmake/toolchain-arm-none-eabi.cmake\"         -DAPPLICATION=\"LoRaMac\"         -DSUB_PROJECT=\"periodic-uplink-lpp\"         -DCLASSB_ENABLED=\"ON\"         -DACTIVE_REGION=\"LORAMAC_REGION_EU868\"         -DREGION_EU868=\"ON\"         -DREGION_US915=\"OFF\"         -DREGION_CN779=\"OFF\"         -DREGION_EU433=\"OFF\"         -DREGION_AU915=\"OFF\"         -DREGION_AS923=\"OFF\"         -DREGION_CN470=\"OFF\"         -DREGION_KR920=\"OFF\"         -DREGION_IN865=\"OFF\"         -DREGION_RU864=\"OFF\"         -DBOARD=\"B-L072Z-LRWAN1\"       -DSECURE_ELEMENT=\"SOFT_SE\"         -DSECURE_ELEMENT_PRE_PROVISIONED=\"OFF\"         -DUSE_RADIO_DEBUG=\"ON\" ..\n\nmake\n</code></pre> <pre><code>cd src/apps/LoRaMac/\n\niotlab-experiment submit -n rtos_ttn -d 60 -l 1,archi=st-lrwan1:sx1276+site=saclay\n{\n    \"id\": 394774\n}\n\niotlab-experiment get -i 394774 -s\n\niotlab-experiment get -i 394774 -r\n\niotlab-node --flash LoRaMac-periodic-uplink-lpp -l saclay,st-lrwan1,10\n\nnc st-lrwan1-10 20000\n</code></pre>"},{"location":"security/","title":"Security","text":"<p>Disclaimer</p> <p>this is not a course on security</p>"},{"location":"simulation/","title":"Simulation of a node","text":"<p>Wokwi is an online Electronics simulator. You can use it to simulate many popular development environment (e.g. Arduino, Esp-idf and RUST just to mention few) boards (e.g. Arduino, ESP32, STM32), parts and sensors. </p> <p>In this course we will focus on the ESP32-DevKit-V1 and initially on the Arduino environment. Working on this environment with the ESP32 allow us to take advantage from the rich availability of libraries, but also to access  advanced and fundamental features provided by FreeRTOS. However, experimenting with the more advanced ESP-idf is strongly encouraged. </p> <p></p> <p>Note</p> <p>An excellent reference for all what concerns the ESP 32 is available at electronic wings </p>"},{"location":"simulation/#lets-start","title":"Let's start","text":"<p>On Wokwi open a new project, select ESP32 as the platform and the Arduino template. </p> <p>If you now open the diagram.json tab you have something like the following in the parts entry</p> <pre><code>\"parts\": [ { \"type\": \"board-esp32-devkit-c-v4\", \"id\": \"esp\", ...} ],\n</code></pre> <p>This implies that the pinout is the one in the devkit v4.  To get the same pinout as the one in the picture above you need a V1 devkit, so you have to modify the entry as in the following</p> <pre><code>\"parts\": [ { \"type\": \"board-esp32-devkit-v1\", \"id\": \"esp\", ...} ],\n</code></pre> <p>To make running the serial interface be sure that under connection you have th following settings</p> <pre><code>\"connections\": [\n    [ \"esp:TX0\", \"$serialMonitor:RX\", \"\", [] ],\n    [ \"esp:RX0\", \"$serialMonitor:TX\", \"\", [] ],\n    .....\n</code></pre> <ul> <li>The simplest actuator, namely a led</li> </ul>"},{"location":"simulation/#understanding-the-breadboard","title":"Understanding the Breadboard","text":""},{"location":"simulation/#the-simplest-digital-sensor-namely-a-button","title":"The Simplest digital sensor, namely a button","text":"<pre><code>#define LED 5\n#define BUTTON 4\n\nint buttonState = 0; \n\nvoid setup() {\n  pinMode(LED, OUTPUT);\n  pinMode(BUTTON, INPUT);\n}\n\nvoid loop() {\n\n  buttonState = digitalRead(BUTTON);\n\n  // check if the pushbutton is pressed. If it is, the buttonState is HIGH:\n  if (buttonState == HIGH) {\n    // turn LED on:\n    digitalWrite(LED, HIGH);\n  } else {\n    // turn LED off:\n    digitalWrite(LED, LOW);\n  }\n}\n</code></pre>"},{"location":"simulation/#a-bit-more-interesting-analog-sensor-namely-a-potentiometer","title":"A bit more interesting analog sensor, namely a potentiometer","text":"<pre><code>int analogPin = 12; // potentiometer wiper (middle terminal) connected to analog pin\n                    // outside leads to ground and +5V\nint val = 0;  // variable to store the value read\n\nvoid setup() {\n  Serial.begin(9600);           //  setup serial\n}\n\nvoid loop() {\n  val = analogRead(analogPin);  // read the input pin\n  Serial.println(val);          // debug value\n  delay(1000);\n}\n</code></pre>"},{"location":"simulation/#quick-overview-of-more-advanced-way-to-interact-with-sensors","title":"Quick overview of more advanced way to interact with sensors","text":""},{"location":"simulation/#an-i2c-sensor-the-mpu6050-accelerometer","title":"An I2C sensor, the MPU6050 Accelerometer","text":"<pre><code>#include &lt;Adafruit_MPU6050.h&gt;\n#include &lt;Adafruit_Sensor.h&gt;\n#include &lt;Wire.h&gt;\nAdafruit_MPU6050 m_p_u;\nvoid setup() {\n  // put your setup code here, to run once:\n  Serial.begin(115200);\n  while(!Serial)\n  delay(20);\n  if(!m_p_u.begin()){\n    while(1){\n      delay(20);\n    }\n  }\n}\n\nvoid loop() {\nsensors_event_t acc, gcc, temp;\nm_p_u.getEvent(&amp;acc, &amp;gcc, &amp;temp);\nSerial.println(\"Acceleration on x axes\");\nSerial.println(acc.acceleration.x);\n  delay(1000); // this speeds up the simulation\n\nSerial.println(\"Acceleration on y axes\");\nSerial.println(acc.acceleration.y);\n  delay(1000);\n\nSerial.println(\"Acceleration on z axes\");\nSerial.println(acc.acceleration.z);\n  delay(1000);\n\nSerial.println(\"Rotation of x axes: \");\nSerial.println((gcc.gyro.x)*180/3.14);\n  delay(1000);\n\n}\n</code></pre> <p>Some more details on the MPU6050 accelerometer and gyroscope. This device can be used for Predictive Maintenance of Motors using Machine Learning or Ensemble Learning for Predictive Maintenance on Wafer Stick Machine Using IoT Sensor Data.</p> <p>A very interesting paper Real-Time Anomaly Detection with LSTM-Autoencoder Network on Microcontrollers for Industrial Applications demonstrates how to implement anomaly detection spending as less as $20.</p>"},{"location":"simulation/#a-simple-scenario","title":"A simple scenario","text":"<p>You want to transform a door into a smart door.</p> <ol> <li>A sensor will tell you when the door is open or closed \u2192 button</li> <li>A visual indicator will clearly show whether the door is open or closed \u2192 led</li> <li>Instead of a simple binary condition open/close you also want to know to what extent the door is open \u2192 potentiometer</li> <li>Finally all these information should be available online</li> </ol>"},{"location":"simulation/#mqtt","title":"MQTT","text":"<p>MQTT is an example of Publish/Subscribe. </p> <p></p> <p>TOPICS:</p> <ol> <li>myhome/groundfloor/livingroom/temperature</li> <li>myhome/groundfloor/bathroom/temperature</li> <li>myhome/groundfloor/bathroom/humidity</li> <li>myhome/firstfloor/bathroom/temperature</li> <li>myhome/groundfloor/+/temperature (1 and 2)</li> <li>myhome/groundfloor/# (1,2 and 3)</li> <li>myhome/# (1,2,3 and 4)</li> </ol>"},{"location":"simulation/#its-time-to-be-connected-by-mqtt","title":"It's time to be connected by MQTT.","text":"<p>A simulation of an MQTT connection is available here on Wokwi.</p> <p>The most convenient way to run on a real device is to use your mobile as an Access Point and configure SSID and password consequently.</p> <p>Note that the topics names are assigned to be consistent with the adafruit dashboard (see example below), but you are free to use any name you like.</p> <pre><code>mosquitto_pub -h test.mosquitto.org -t \"avitaletti/feeds/threshold\" -m 2345\n</code></pre> <pre><code>mosquitto_sub -h test.mosquitto.org -t \"avitaletti/feeds/potentiometer\"\n</code></pre> <p>Tip</p> <ul> <li>A multi platform easy to use alternative is https://mqtt-explorer.com/</li> <li>Another possible broker is mqtt://mqtt.eclipseprojects.io</li> </ul> <p></p>"},{"location":"simulation/#build-a-simple-backend-with-httpsioadafruitcom","title":"Build a simple backend with https://io.adafruit.com/","text":"<ul> <li>Create an account on io.adafruit.com, in my case the username is avitaletti.</li> <li>Click on the yellow key to get yor credentials to publish data</li> </ul> <p><pre><code>#define IO_USERNAME  \"avitaletti\"\n#define IO_KEY       \"xxxxxxxxxxxxxxxxxxxx\"\n</code></pre> * Create two feeds named threshold and potentiometer with the corresponding topics avitaletti/feeds/threshold  and avitaletti/feeds/potentiometer</p> <p></p> <p>The following code will publish the message 33 on the topic avitaletti/feeds/potentiometer and it is used by the IoT device to send the data acquired by the ADC</p> <pre><code>mosquitto_pub -h io.adafruit.com -u avitaletti -P xxxxxxxxxxxxxxxxxxxx -t avitaletti/feeds/potentiometer -m 33\n</code></pre> <p>The node can subscribe to avitaletti/feeds/threshold  to get the commands from the backend</p> <pre><code>mosquitto_sub -h io.adafruit.com -u avitaletti -P xxxxxxxxxxxxxxxxxxxx -t avitaletti/feeds/threshold\n</code></pre> <ul> <li>The dashboard link the components to the feeds and corresponding topics</li> </ul> <p></p> <p>In other words when the device publishes on the avitaletti/feeds/potentiometer topic a new entry is created in the line chart, while when you move the slider the corresponding value is published on avitaletti/feeds/threshold</p>"},{"location":"simulation/#build-a-simple-backend-with-thingsboard-httpsdemothingsboardiologin","title":"Build a simple backend with thingsboard https://demo.thingsboard.io/login","text":"<p>https://thingsboard.io/docs/getting-started-guides/helloworld/?connectdevice=mqtt-linux</p> <pre><code>mosquitto_pub -d -q 1 -h \"$THINGSBOARD_HOST_NAME\" -p \"1883\" -t \"v1/devices/me/telemetry\" -u \"$ACCESS_TOKEN\" -m {\"temperature\":25}\n</code></pre> <p>NOTE: for the sake of convenience, we will use WiFi connectivity, however it should be now clear WiFi is usually not appropriate for IoT applications due to the excessive energy demand. </p>"},{"location":"twin/","title":"Digital Twin","text":""},{"location":"twin/#maintenance","title":"Maintenance","text":"<ul> <li>Periodic</li> <li>Preventive</li> <li>Predictive</li> <li>Reactive</li> </ul>"},{"location":"twin/#the-difference-between-static-and-dynamic-unbalance","title":"The difference between Static and Dynamic Unbalance","text":""},{"location":"twin/#a-simple-experiment","title":"A simple experiment","text":"<p>code</p>"},{"location":"twin/#a-simple-model","title":"A simple model","text":"<p>Centrifugal force of a mass \\(m_e\\) at distance \\(r\\) from the center of rotation, with angular velocity \\(\\omega\\): \\(F\u200b=m_e \u200br \\omega\\)</p> <p>Using a lumped mass model, and assuming the damping coefficient and the stiffness of the support are negligible, if the mass or the rotor is \\(m\\), we can write :</p> <p>\\(m \\ddot{x} = m_e \u200br \\omega^2 cos(\\omega t)\\)</p> <p>\\(m \\ddot{y} = m_e \u200br \\omega^2 sin(\\omega t)\\)</p> <p>This allows us to estimate the accelerations under the simplistic assumptions we made. </p>"},{"location":"web3/","title":"IoT and Web3","text":"<p>In Blockchain as IoT Economy Enabler: A Review of Architectural Aspects we discuss how the IoT can benefit in interfacing the Blockchain and Web3 technologies. </p> <p>What if sharing a tiny space in your refrigerator could help preserve seed diversity? </p> <p>The Food and Agriculture Organization (FAO), estimates that 75% of crop diversity was lost since the 1900s. That lack of diversity presents a severe risk to the security of global food systems. Without seed diversity, it is difficult for plants to adapt to pests, diseases, and changing climate conditions.</p> <p>More details are available on the paper on arXiv</p> <p>source code</p>"},{"location":"wireless/","title":"Wireless Connectivity","text":"<p>For the sake of convenience, we use WiFi connectivity, a WiFi Access Point is available everywhere and we can even use our mobile phone in tethering, however:</p> <p>Warning</p> <p>WiFi is not appropriate for IoT connectivity since it is power demanding</p> <p>The selection of the most appropriate wireless connectivity technology depends mostly on the application requirements and it is usually a tradeoff among energy, data throughput, coverage and cost.</p> <p>The following table compares different wireless technologies. WiFi has the highest figures in terms of energy consumptions. </p> <p></p> <p>In our experiments, we us LoRaWAN. In particular, we have a Gateway connected to The Thing Network (TTN).</p> <p>Heltec, produces a nice device, the WiFi LoRa 32(V3), that we use in our experiments. </p> <p>A simple code to establish a first connection si available here. </p> <p>It is basically the ttn-otaa example available in the rgot-org/TTN_esp32 library.</p> <p></p>"}]}